using System;
using System.ComponentModel;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using System.Text;
using MimeMapping;
using Azure.Storage;
using Azure.Storage.Blobs;
using Azure.Storage.Blobs.Models;
using Azure.Storage.Blobs.Specialized;
using System.IO.Compression;
using Frends.AzureBlobStorage.UploadBlob.Definitions;

namespace Frends.AzureBlobStorage.UploadBlob;
/// <summary>
/// Azure Blob Storage Task.
/// </summary>
public class AzureBlobStorage
{
    /// <summary>
    /// Uploads a single file to Azure blob storage.
    /// </summary>
    /// <param name="source">Source parameters</param>
    /// <param name="destination">Destination parameters</param>
    /// <param name="cancellationToken">Token generated by Frends to stop this task.</param>
    /// <returns>Object { string Uri, string SourceFile }</returns>
    public static async Task<Result> UploadBlob([PropertyTab] Source source, [PropertyTab] Destination destination, CancellationToken cancellationToken)
    {
        var fi = new FileInfo(source.SourceFile);
        if (!fi.Exists) throw new ArgumentException("Source file doesn't exists.");

        var blob = new BlobClient(destination.ConnectionString, destination.ContainerName, destination.BlobName);

        if (destination.HandleExistingFile.Equals(HandleExistingFile.Error) && await BlobExists(destination, cancellationToken)) throw new Exception("UploadBlob: Blob already exists.");
        if (destination.HandleExistingFile.Equals(HandleExistingFile.Overwrite) && await BlobExists(destination, cancellationToken)) await blob.DeleteIfExistsAsync(DeleteSnapshotsOption.None, null, cancellationToken);
        if (destination.HandleExistingFile.Equals(HandleExistingFile.Append) && await BlobExists(destination, cancellationToken)) fi = await AppendAny(source, destination, cancellationToken);

        if (fi != null)
        {
            var fileName = RenameFile(source, destination, fi);
            return await HandleUpload(source, destination, fi, fileName, cancellationToken);
        }
        else
            return new Result { SourceFile = source.SourceFile, Uri = blob.Uri.ToString() };
    }

    private static async Task<Result> HandleUpload(Source source, Destination destination, FileInfo fi, string fileName, CancellationToken cancellationToken)
    {
            if (destination.CreateContainerIfItDoesNotExist) await CreateContainerIfItDoesNotExist(destination, cancellationToken);

            var contentType = string.IsNullOrWhiteSpace(destination.ContentType) ? MimeUtility.GetMimeMapping(fi.Name) : destination.ContentType;
            var encoding = GetEncoding(destination.FileEncoding);

            var progressHandler = new Progress<long>(progress => { Console.WriteLine("Bytes uploaded: {0}", progress); });

            switch (destination.BlobType)
            {
                case AzureBlobType.Append:
                    try
                    {
                        var appendBlobClient = new AppendBlobClient(destination.ConnectionString, destination.ContainerName, fileName);
                        var appendBlobCreateOptions = new AppendBlobCreateOptions { HttpHeaders = new BlobHttpHeaders { ContentType = contentType, ContentEncoding = source.Compress ? "gzip" : encoding.WebName } };
                        await appendBlobClient.CreateAsync(appendBlobCreateOptions, cancellationToken);
                        using var appendGetStream = GetStream(false, true, encoding, fi);
                        await appendBlobClient.AppendBlockAsync(appendGetStream, null, null, progressHandler, cancellationToken);
                        return new Result { SourceFile = source.SourceFile, Uri = appendBlobClient.Uri.ToString() };
                    }
                    catch (Exception ex)
                    {
                        throw new Exception($"UploadBlob (Append): An error occured while uploading file. {ex}");
                    }

                case AzureBlobType.Block:
                    try
                    {
                        var blobClient = new BlobClient(destination.ConnectionString, destination.ContainerName, fileName);
                        var blobUploadOptions = new BlobUploadOptions
                        {
                            ProgressHandler = progressHandler,
                            TransferOptions = new StorageTransferOptions { MaximumConcurrency = destination.ParallelOperations },
                            HttpHeaders = new BlobHttpHeaders { ContentType = contentType, ContentEncoding = source.Compress ? "gzip" : encoding.WebName }
                        };
                        using var blockGetStream = GetStream(source.Compress, source.ContentsOnly, encoding, fi);
                        await blobClient.UploadAsync(blockGetStream, blobUploadOptions, cancellationToken);
                    
                        //Delete temp file
                        if (Path.GetDirectoryName(fi.FullName) != Path.GetDirectoryName(source.SourceFile)) fi.Delete();

                        return new Result { SourceFile = source.SourceFile, Uri = blobClient.Uri.ToString() };

                    }
                    catch (Exception ex)
                    {
                        throw new Exception($"UploadBlob (Block): An error occured while uploading file. {ex}");
                    }

                case AzureBlobType.Page:
                    try
                    {
                        var pageBlobClient = new PageBlobClient(destination.ConnectionString, destination.ContainerName, fileName);
                        var maxSize = destination.PageMaxSize < 512 ? 512 : destination.PageMaxSize;
                        var fiMinLenght = fi.Length;

                        //Upload size can't be over Page's full size.
                        while (maxSize % 512 != 0) maxSize += (maxSize / 512);
                        while (fiMinLenght % 512 != 0) fiMinLenght += (fiMinLenght / 512);
                        while (maxSize < fiMinLenght) maxSize += 512;

                        if (destination.HandleExistingFile.Equals(HandleExistingFile.Overwrite)) await pageBlobClient.DeleteIfExistsAsync(DeleteSnapshotsOption.None, null, cancellationToken);

                        if (fiMinLenght > 8796093022208 || maxSize > 8796093022208) //Handle over 8 TB
                            throw new Exception($"UploadPageBlob: Required minimum size of Page is over 8 TB. File's minumum size: {fiMinLenght} bytes, Page maximum size: {maxSize} bytes.");

                        using var pageGetStream = GetStream(false, true, encoding, fi);
                        await pageBlobClient.CreateAsync(maxSize, cancellationToken: cancellationToken);
                        await pageBlobClient.UploadPagesAsync(pageGetStream, destination.PageOffset == -1 ? maxSize - fiMinLenght : destination.PageOffset, cancellationToken: cancellationToken);

                        //Delete temp file
                        if (Path.GetDirectoryName(fi.FullName) != Path.GetDirectoryName(source.SourceFile)) fi.Delete();

                        return new Result { SourceFile = source.SourceFile, Uri = pageBlobClient.Uri.ToString() };
                    }
                    catch (Exception ex)
                    {
                        throw new Exception($"UploadBlob (Page): An error occured while uploading file. {ex}");
                    }

            ////Handle CS0161
            default: throw new Exception("HandleUpload: An error occured while uploading file. Missing Azure Blob type."); // return new Result { SourceFile = source.SourceFile, Uri = null };
        }
        
    }

    private static async Task<bool> BlobExists(Destination destination, CancellationToken cancellationToken)
    {
        try
        {
            var blob = new BlobClient(destination.ConnectionString, destination.ContainerName, destination.BlobName);
            return await blob.ExistsAsync(cancellationToken);
        }
        catch (Exception ex)
        {
            throw new Exception($"BlobExists: An error occured while checking if blob exists. {ex}");
        }
    }

    private static string RenameFile(Source source, Destination destination, FileInfo fi)
    {
        try
        {
            string fileName;
            if (string.IsNullOrWhiteSpace(destination.RenameTo) && source.Compress) fileName = fi.Name + ".gz";
            else if (string.IsNullOrWhiteSpace(destination.RenameTo)) fileName = fi.Name;
            else fileName = destination.RenameTo;
            return fileName;
        }
        catch (Exception ex)
        {
            throw new Exception($"RenameFile: An error occured while renaming file. {ex}");
        }
    }

    private static async Task CreateContainerIfItDoesNotExist(Destination destination, CancellationToken cancellationToken)
    {
        try
        {
            var blobServiceClient = new BlobServiceClient(destination.ConnectionString);
            var container = blobServiceClient.GetBlobContainerClient(destination.ContainerName);
            await container.CreateIfNotExistsAsync(PublicAccessType.None, null, null, cancellationToken);
        }
        catch (Exception ex)
        {
            throw new Exception($"CreateContainerIfItDoesNotExist: An error occured while checking if container exists or while creating a new container.{ex}");
        }
    }

    private static async Task<FileInfo> AppendAny(Source source, Destination destination, CancellationToken cancellationToken)
    {
        try
        {
            var blob = new BlobClient(destination.ConnectionString, destination.ContainerName, destination.BlobName);
            var blobProperties = blob.GetPropertiesAsync(cancellationToken: cancellationToken);

            //Block and Page blobs must be downloaded and handled in temp because file size can be too large for memory stream.
            if (blobProperties.Result.Value.BlobType.Equals(BlobType.Append))
            {
                var appendBlob = new AppendBlobClient(destination.ConnectionString, destination.ContainerName, destination.BlobName);
                var appendBlobMaxAppendBlockBytes = appendBlob.AppendBlobMaxAppendBlockBytes;

                using var file = File.OpenRead(source.SourceFile);
                int bytesRead;
                var buffer = new byte[appendBlobMaxAppendBlockBytes];
                while ((bytesRead = file.Read(buffer, 0, buffer.Length)) > 0)
                {
                    var newArray = new Span<byte>(buffer, 0, bytesRead).ToArray();
                    Stream stream = new MemoryStream(newArray) { Position = 0 };
                    await appendBlob.AppendBlockAsync(stream, cancellationToken: cancellationToken);
                }

                // Return null to skip uploading.
                return null; 
            }
            else
            {
                var tempFile = Path.Combine(Path.GetTempPath(), destination.BlobName);
                await blob.DownloadToAsync(tempFile, cancellationToken);

                using (var sourceData = new StreamReader(source.SourceFile))
                using (var destinationFile = File.AppendText(tempFile))
                {
                    var line = sourceData.ReadLine();
                    destinationFile.Write(line); //WriteLine will mess up Page blob upload.
                };

                return new FileInfo(tempFile);
            }
        }
        catch (Exception ex)
        {
            throw new Exception($"AppendAny: An error occured while appending file. {ex}");
        }
    }

    /// <summary>
    /// Gets correct stream object. Does not always dispose, so use using.
    /// </summary>
    private static Stream GetStream(bool compress, bool fromString, Encoding encoding, FileInfo file)
    {
        var fileStream = File.OpenRead(file.FullName);

        if (!compress && !fromString) return fileStream;

        byte[] bytes;
        if (!compress)
        {
            using (var reader = new StreamReader(fileStream, encoding)) bytes = encoding.GetBytes(reader.ReadToEnd());
            return new MemoryStream(bytes);
        }

        using (var outStream = new MemoryStream())
        {
            using (var gzip = new GZipStream(outStream, CompressionMode.Compress))
            {
                if (!fromString) fileStream.CopyTo(gzip);
                else
                    using (var reader = new StreamReader(fileStream, encoding))
                    {
                        var content = reader.ReadToEnd();
                        using var encodedMemory = new MemoryStream(encoding.GetBytes(content));
                        encodedMemory.CopyTo(gzip);
                    }
            }
            bytes = outStream.ToArray();
        }
        fileStream.Dispose();

        var memStream = new MemoryStream(bytes);
        return memStream;
    }

    private static Encoding GetEncoding(string target)
    {
        return target.ToLower() switch
        {
            "utf-32" => Encoding.UTF32,
            "unicode" => Encoding.Unicode,
            "ascii" => Encoding.ASCII,
            _ => Encoding.UTF8,
        };
    }
}