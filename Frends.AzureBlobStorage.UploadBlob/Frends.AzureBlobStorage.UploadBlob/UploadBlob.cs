using Azure;
using Azure.Identity;
using Azure.Storage;
using Azure.Storage.Blobs;
using Azure.Storage.Blobs.Models;
using Azure.Storage.Blobs.Specialized;
using Frends.AzureBlobStorage.UploadBlob.Definitions;
using MimeMapping;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Frends.AzureBlobStorage.UploadBlob;

/// <summary>
/// Azure Blob Storage Task.
/// </summary>
public class AzureBlobStorage
{
    /// <summary>
    /// Frends Task to upload blobs to Azure Blob Storage.
    /// [Documentation](https://tasks.frends.com/tasks/frends-tasks/Frends.AzureBlobStorage.UploadBlob)
    /// </summary>
    /// <param name="input">Input parameters.</param>
    /// <param name="connection">Connection parameters.</param>
    /// <param name="options">Optional parameters.</param>
    /// <param name="cancellationToken">Token generated by Frends to stop this Task.</param>
    /// <returns>Object { bool Success, Dictionary&lt;string, string&gt; Data }</returns>
    public static async Task<Result> UploadBlob([PropertyTab] Input input, [PropertyTab] Connection connection, [PropertyTab] Options options, CancellationToken cancellationToken)
    {
        var results = new Dictionary<string, string>();

        var fi = string.IsNullOrEmpty(input.SourceFile) ? null : new FileInfo(input.SourceFile);
        var handledFile = string.Empty;

        try
        {
            CheckParameters(input, connection);
            var blobName = string.Empty;

            if (connection.CreateContainerIfItDoesNotExist && (connection.ConnectionMethod is ConnectionMethod.ConnectionString || connection.ConnectionMethod is ConnectionMethod.OAuth2))
                await CreateContainerIfItDoesNotExist(connection, connection.ContainerName.ToLower(), cancellationToken);

            switch (input.SourceType)
            {
                case UploadSourceType.File:
                    if (fi == null)
                        throw new FileNotFoundException($"Source file '{input.SourceFile}' was empty.");
                    blobName = fi.Name;
                    if (!string.IsNullOrWhiteSpace(input.BlobName) || input.Compress)
                        blobName = RenameFile(!string.IsNullOrEmpty(input.BlobName) ? input.BlobName : fi.Name, input.Compress, fi);
                    results.Add(input.SourceFile, await HandleUpload(input, connection, options, fi, blobName, cancellationToken));
                    break;
                case UploadSourceType.Directory:
                    var dir = string.IsNullOrEmpty(input.SourceDirectory) ? null : input.SourceDirectory;
                    foreach (var file in Directory.GetFiles(dir, string.IsNullOrEmpty(input.SearchPattern) ? "*.*" : input.SearchPattern, SearchOption.AllDirectories)
                        .Select(e => new FileInfo(e)))
                    {
                        var fileName = file.Name;
                        if (input.Compress)
                            fileName = RenameFile(fileName, input.Compress, file);

                        var parentDirectory = Path.GetFileName(Path.GetDirectoryName(file.ToString()));
                        var withDir = string.IsNullOrEmpty(input.BlobFolderName)
                            ? Path.Combine(parentDirectory, fileName)
                            : Path.Combine(input.BlobFolderName, fileName);

                        blobName = withDir.Replace("\\", "/");

                        results.Add(file.FullName, await HandleUpload(input, connection, options, file, blobName, cancellationToken));
                        handledFile = file.FullName;
                    }

                    if (!results.Any())
                    {
                        if (options.ThrowErrorOnFailure)
                            throw new Exception(@$"No files were found in the directory {dir}.");
                        else
                            results.Add(null, @$"No files were found in the directory {dir}.");
                    }
                    break;
                default:
                    throw new Exception("Invalid source.");
            }
        }
        catch (Exception ex)
        {
            var error = new Dictionary<string, string>();
            if (input.SourceType is UploadSourceType.File)
            {
                if (options.ThrowErrorOnFailure)
                    throw new Exception("An exception occured.", ex);
                else
                {
                    if (fi == null)
                        error.Add(string.Empty, $@"An exception occured. {ex}");
                    else
                        error.Add(fi.FullName, $@"An exception occured. {ex}");
                    return new Result(false, error);
                }
            }
            else
            {
                if (options.ThrowErrorOnFailure)
                    throw new Exception($@"An exception occured while uploading directory. Last handled file: {handledFile}", ex);
                else
                {
                    error.Add(string.Empty, $@"An exception occured while uploading directory. Last handled file: {handledFile}. {ex}");
                    return new Result(false, error);
                }
            }
        }

        return new Result(true, results);
    }

    private static async Task<string> HandleUpload(Input input, Connection connection, Options options, FileInfo fi, string blobName, CancellationToken cancellationToken)
    {
        blobName = string.IsNullOrEmpty(input.BlobName) ? blobName : input.BlobName;

        var contentType = string.IsNullOrEmpty(options.ContentType) ? MimeUtility.GetMimeMapping(fi.Name) : options.ContentType;
        var encoding = GetEncoding(options.Encoding, options.FileEncodingString, options.EnableBom);

        var tags = input.Tags != null ? input.Tags.ToDictionary(tag => tag.Name, tag => tag.Value) : new Dictionary<string, string>();

        var credentials = connection.ConnectionMethod is ConnectionMethod.OAuth2 ? new ClientSecretCredential(connection.TenantId, connection.ApplicationId, connection.ClientSecret, new ClientSecretCredentialOptions()) : null;

        BlobContainerClient containerClient = null;

        if (connection.ConnectionMethod is ConnectionMethod.ConnectionString)
        {
            containerClient = new BlobContainerClient(connection.ConnectionString, connection.ContainerName.ToLower());
        }
        else if (connection.ConnectionMethod is ConnectionMethod.SasToken)
        {
            var baseUri = connection.Uri.TrimEnd('/');
            containerClient = new BlobContainerClient(new Uri($"{connection.Uri}/{connection.ContainerName}?"), new AzureSasCredential(connection.SasToken));
        }

        var overwrite = input.ActionOnExistingFile == OnExistingFile.Overwrite;

        switch (options.BlobType)
        {
            case AzureBlobType.Append:
                try
                {
                    AppendBlobClient appendBlobClient = connection.ConnectionMethod is ConnectionMethod.OAuth2 ? new AppendBlobClient(new Uri($"{connection.Uri}/{connection.ContainerName.ToLower()}/{blobName}"), credentials) : containerClient.GetAppendBlobClient(blobName);

                    var exists = false;
                    exists = await appendBlobClient.ExistsAsync(cancellationToken);

                    if (exists && input.ActionOnExistingFile is OnExistingFile.Throw)
                    {
                        if (!options.ThrowErrorOnFailure)
                            return @$"Blob {blobName} already exists.";
                        else
                            throw new Exception(@$"Blob {blobName} already exists.");
                    }

                    if (exists && input.ActionOnExistingFile is OnExistingFile.Overwrite)
                    {

                        await appendBlobClient.DeleteIfExistsAsync(DeleteSnapshotsOption.None, null, cancellationToken);
                        exists = false;
                    }

                    if (exists && input.ActionOnExistingFile is OnExistingFile.Append)
                        fi = await AppendAny(appendBlobClient, blobName, input.SourceFile, cancellationToken);

                    if (fi != null)
                    {
                        var appendBlobCreateOptions = new AppendBlobCreateOptions
                        {
                            HttpHeaders = new BlobHttpHeaders { ContentType = contentType, ContentEncoding = input.Compress ? "gzip" : encoding.WebName },
                            Tags = tags.Count > 0 ? tags : null
                        };

                        await appendBlobClient.CreateAsync(appendBlobCreateOptions, cancellationToken);
                        using var appendGetStream = new MemoryStream(GetBytes(false, true, encoding, fi));
                        await appendBlobClient.AppendBlockAsync(appendGetStream, null, null, null, cancellationToken);
                    }

                    return appendBlobClient.Uri.ToString();
                }
                catch (Exception ex)
                {
                    throw new Exception($"UploadBlob (Append): An error occured while uploading {blobName}.", ex);
                }

            case AzureBlobType.Block:
                try
                {
                    var blobname = blobName;
                    BlobClient blobClient = connection.ConnectionMethod is ConnectionMethod.OAuth2 ? new BlobClient(new Uri($"{connection.Uri}/{connection.ContainerName.ToLower()}/{blobName}"), credentials) : containerClient.GetBlobClient(blobName);

                    var exists = await blobClient.ExistsAsync(cancellationToken);

                    if (exists.Value && input.ActionOnExistingFile is OnExistingFile.Throw)
                    {
                        if (!options.ThrowErrorOnFailure)
                            return @$"Blob {blobName} already exists.";
                        else
                            throw new Exception(@$"Blob {blobName} already exists.");
                    }

                    var blobUploadOptions = new BlobUploadOptions
                    {
                        Conditions = overwrite ? null : new BlobRequestConditions { IfNoneMatch = new ETag("*") },
                        TransferOptions = new StorageTransferOptions { MaximumConcurrency = options.ParallelOperations },
                        HttpHeaders = new BlobHttpHeaders { ContentType = contentType, ContentEncoding = input.Compress ? "gzip" : encoding.WebName },
                        Tags = tags.Count > 0 ? tags : null,
                    };

                    if (exists.Value && input.ActionOnExistingFile is OnExistingFile.Overwrite)
                        await blobClient.DeleteIfExistsAsync(DeleteSnapshotsOption.None, null, cancellationToken);

                    if (exists.Value && input.ActionOnExistingFile is OnExistingFile.Append)
                    {
                        fi = await AppendAny(blobClient, blobName, input.SourceFile, cancellationToken);
                        await blobClient.DeleteIfExistsAsync(DeleteSnapshotsOption.None, null, cancellationToken);
                    }

                    await blobClient.UploadAsync(BinaryData.FromBytes(GetBytes(input.Compress, input.ContentsOnly, encoding, fi)), blobUploadOptions, cancellationToken);

                    //Delete temp file
                    if (File.Exists(fi.FullName) && Path.GetDirectoryName(fi.FullName) != Path.GetDirectoryName(input.SourceFile) && Path.GetDirectoryName(fi.FullName) != input.SourceDirectory)
                        fi.Delete();

                    return blobClient.Uri.ToString();
                }
                catch (Exception ex)
                {
                    throw new Exception($"UploadBlob (Block): An error occured while uploading {blobName}.", ex);
                }

            case AzureBlobType.Page:
                try
                {
                    PageBlobClient pageBlobClient = connection.ConnectionMethod is ConnectionMethod.OAuth2 ? new PageBlobClient(new Uri($"{connection.Uri}/{connection.ContainerName.ToLower()}/{blobName}"), credentials) : containerClient.GetPageBlobClient(blobName);

                    var origSize = 0;
                    var exists = false;
                    exists = await pageBlobClient.ExistsAsync(cancellationToken);

                    if (exists && input.ActionOnExistingFile is OnExistingFile.Throw)
                    {
                        if (options.ThrowErrorOnFailure)
                            throw new Exception(@$"Blob {blobName} already exists.");
                        else
                            return @$"Blob {blobName} already exists.";
                    }

                    if (exists && input.ActionOnExistingFile is OnExistingFile.Overwrite)
                    {
                        await pageBlobClient.DeleteIfExistsAsync(DeleteSnapshotsOption.None, null, cancellationToken);
                        exists = false;
                    }

                    if (exists && input.ActionOnExistingFile is OnExistingFile.Append)
                    {
                        origSize = pageBlobClient.PageBlobPageBytes;
                        fi = await AppendAny(pageBlobClient, blobName, input.SourceFile, cancellationToken);
                    }

                    var bytesMissing = 0;

                    var requiredSize = options.PageMaxSize < 512 ? 512 : options.PageMaxSize;
                    var fiMinLenght = new FileInfo(fi.FullName).Length;
                    while ((fiMinLenght + bytesMissing) % 512 != 0)
                        bytesMissing++;

                    if (requiredSize < (fiMinLenght + bytesMissing))
                        requiredSize = fiMinLenght + bytesMissing;

                    if (requiredSize > 8796093022208) //Handle over 8 TB
                        throw new Exception($"UploadPageBlob, blob {blobName}: Required minimum size of Page is over 8 TB and size must be multiple of 512. Required size that is multiple of 512 is {requiredSize} bytes.");

                    // Fill file until size is multiple of 512.
                    if (options.ResizeFile && bytesMissing > 0)
                    {
                        using var fileStream = new FileStream(fi.FullName, FileMode.Append);

                        fileStream.Write(new byte[bytesMissing], 0, bytesMissing);

                        if (exists)
                            await pageBlobClient.ResizeAsync(fiMinLenght + bytesMissing, cancellationToken: cancellationToken);
                    }

                    using var pageGetStream = new MemoryStream(GetBytes(false, true, encoding, fi));

                    if (!exists)
                        await pageBlobClient.CreateAsync(requiredSize, cancellationToken: cancellationToken);

                    await pageBlobClient.UploadPagesAsync(pageGetStream, offset: options.PageOffset == -1 ? origSize : options.PageOffset, cancellationToken: cancellationToken);

                    if (Path.GetDirectoryName(fi.FullName) != Path.GetDirectoryName(input.SourceFile) && Path.GetDirectoryName(fi.FullName) != input.SourceDirectory)
                        fi.Delete();

                    return pageBlobClient.Uri.ToString();
                }
                catch (Exception ex)
                {
                    throw new Exception($"UploadBlob (Page): An error occured while uploading {blobName}. {ex}");
                }

            default: throw new Exception(@$"HandleUpload: An error occured while uploading {blobName}. Missing Azure Blob type.");
        }
    }

    private static string RenameFile(string renameTo, bool compress, FileInfo fi)
    {
        try
        {
            string fileName;

            if (string.IsNullOrEmpty(renameTo) && compress)
                fileName = fi.Name + ".gz";
            else if (string.IsNullOrEmpty(renameTo))
                fileName = fi.Name;
            else
                fileName = renameTo;

            return fileName;
        }
        catch (Exception ex)
        {
            throw new Exception($"An error occured while renaming file. {ex}");
        }
    }

    private static async Task CreateContainerIfItDoesNotExist(Connection connection, string containerName, CancellationToken cancellationToken)
    {
        try
        {
            BlobServiceClient blobServiceClient;
            if (connection.ConnectionMethod is ConnectionMethod.ConnectionString)
            {
                blobServiceClient = new BlobServiceClient(connection.ConnectionString);
            }
            else if (connection.ConnectionMethod is ConnectionMethod.SasToken)
            {
                var serviceURI = new Uri($"{connection.Uri}");
                blobServiceClient = new BlobServiceClient(serviceURI, new AzureSasCredential(connection.SasToken));
            }
            else
            {
                var serviceURI = new Uri($"{connection.Uri}");
                var credentials = new ClientSecretCredential(connection.TenantId, connection.ApplicationId, connection.ClientSecret, new ClientSecretCredentialOptions());
                blobServiceClient = new BlobServiceClient(serviceURI, credentials);
            }

            var container = blobServiceClient.GetBlobContainerClient(containerName);
            await container.CreateIfNotExistsAsync(PublicAccessType.None, null, null, cancellationToken);
        }
        catch (Exception ex)
        {
            throw new Exception($"An error occured while checking if container exists or while creating a new container. {ex}");
        }
    }

    private static async Task<FileInfo> AppendAny(BlobBaseClient blobClient, string blobName, string sourceFile, CancellationToken cancellationToken)
    {
        try
        {
            BlobProperties blobProperties = null;

            blobProperties = await blobClient.GetPropertiesAsync(cancellationToken: cancellationToken);

            if (blobProperties == null)
                throw new Exception("Blob properties couldn't be fetched.");

            //Block and Page blobs need to be downloaded and handled in temp because file size can be too large for memory stream.
            if (blobProperties.BlobType.Equals(BlobType.Append))
            {
                var appendBlobMaxAppendBlockBytes = ((AppendBlobClient)blobClient).AppendBlobMaxAppendBlockBytes;

                using var file = File.OpenRead(sourceFile);
                {
                    int bytesRead;
                    var buffer = new byte[appendBlobMaxAppendBlockBytes];
                    while ((bytesRead = await file.ReadAsync(buffer, cancellationToken)) > 0)
                    {
                        var newArray = new Span<byte>(buffer, 0, bytesRead).ToArray();
                        using Stream stream = new MemoryStream(newArray) { Position = 0 };
                        await ((AppendBlobClient)blobClient).AppendBlockAsync(stream, cancellationToken: cancellationToken);
                    }
                }

                return null;
            }
            else
            {
                var tempFile = Path.Combine(Path.GetTempPath(), blobName);
                await blobClient.DownloadToAsync(tempFile, cancellationToken);

                using var sourceData = new StreamReader(sourceFile);
                using var destinationFile = File.AppendText(tempFile);
                var line = await sourceData.ReadLineAsync();
                await destinationFile.WriteAsync(line);

                return new FileInfo(tempFile);
            }
        }
        catch (Exception ex)
        {
            throw new Exception($"AppendAny: An error occured while appending file. {ex}");
        }
    }

    private static byte[] GetBytes(bool compress, bool fromString, Encoding encoding, FileInfo file)
    {
        var fileStream = File.OpenRead(file.FullName);

        try
        {
            if (!compress)
            {
                using var reader = new StreamReader(fileStream, encoding);
                return encoding.GetBytes(reader.ReadToEnd());
            }

            using var outStream = new MemoryStream();
            using (var gzip = new GZipStream(outStream, CompressionMode.Compress, true))
            {
                if (!fromString)
                {
                    fileStream.CopyTo(gzip);
                }
                else
                {
                    using var reader = new StreamReader(fileStream, encoding);
                    var content = reader.ReadToEnd();
                    using var encodedMemory = new MemoryStream(encoding.GetBytes(content));
                    encodedMemory.CopyTo(gzip);
                }
            }

            return outStream.ToArray();
        }
        finally
        {
            fileStream.Dispose();
        }
    }

    private static Encoding GetEncoding(FileEncoding encoding, string encodingString, bool enableBom)
    {
        return encoding switch
        {
            FileEncoding.UTF8 => enableBom ? new UTF8Encoding(true) : new UTF8Encoding(false),
            FileEncoding.ASCII => new ASCIIEncoding(),
            FileEncoding.Default => Encoding.Default,
            FileEncoding.Windows1252 => CodePagesEncodingProvider.Instance.GetEncoding("windows-1252"),
            FileEncoding.Other => CodePagesEncodingProvider.Instance.GetEncoding(encodingString),
            _ => throw new ArgumentOutOfRangeException($"Unknown Encoding type: '{encoding}'."),
        };
    }

    private static void CheckParameters(Input input, Connection connection)
    {
        if (input.SourceType is UploadSourceType.Directory && !string.IsNullOrEmpty(input.SourceDirectory) && !Directory.Exists(input.SourceDirectory))
            throw new Exception(@$"Source directory {input.SourceDirectory} doesn't exists.");
        if (input.SourceType is UploadSourceType.Directory && (string.IsNullOrEmpty(input.SourceDirectory) || !Directory.EnumerateFileSystemEntries(input.SourceDirectory).Any()))
            throw new Exception(@$"Source.SourceDirectory value is empty.");
        if (input.SourceType is UploadSourceType.File && string.IsNullOrEmpty(input.SourceFile))
            throw new Exception("Source.SourceFile value is empty.");
        if (input.SourceType is UploadSourceType.File && !File.Exists(input.SourceFile))
            throw new Exception("Source.SourceFile not found.");
        if (connection.ConnectionMethod is ConnectionMethod.OAuth2 && (string.IsNullOrEmpty(connection.ApplicationId) || string.IsNullOrEmpty(connection.ClientSecret) || string.IsNullOrEmpty(connection.TenantId) || string.IsNullOrEmpty(connection.Uri)))
            throw new Exception("Destination.StorageAccountName, Destination.ClientSecret, Destination.ApplicationID and Destination.TenantID parameters can't be empty when Destination.ConnectionMethod = OAuth.");
        if (connection.ConnectionMethod is ConnectionMethod.ConnectionString && string.IsNullOrEmpty(connection.ConnectionString))
            throw new Exception("Destination.ConnectionString parameter can't be empty when Destination.ConnectionMethod = ConnectionString.");
        if (connection.ConnectionMethod is ConnectionMethod.SasToken)
        {
            if (string.IsNullOrEmpty(connection.Uri) || string.IsNullOrEmpty(connection.SasToken))
                throw new Exception("Destination.SASToken and Destination.URI parameters can't be empty when Destination.ConnectionMethod = SASToken.");
            if (!Uri.TryCreate(connection.Uri, UriKind.Absolute, out _))
                throw new Exception("Destination.URI must be a valid absolute URI.");
            if (!connection.SasToken.Contains("sig="))
                throw new Exception("Destination.SASToken appears to be invalid. It should contain a signature.");
        }
        if (string.IsNullOrEmpty(connection.ContainerName))
            throw new Exception("Destination.ContainerName parameter can't be empty.");
    }
}