using System;
using System.ComponentModel;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using System.Text;
using Frends.AzureBlobStorage.UploadBlob.Definitions;
using System.Reflection;
using System.Runtime.Loader;
using Azure.Storage.Blobs;
using Azure.Storage.Blobs.Models;
using Azure.Storage.Blobs.Specialized;
using Azure.Storage;
using MimeMapping;
using System.IO.Compression;
using Azure.Identity;

namespace Frends.AzureBlobStorage.UploadBlob;
/// <summary>
/// Azure Blob Storage Task.
/// </summary>
public class AzureBlobStorage
{
    /// For mem cleanup.
    static AzureBlobStorage()
    {
        var currentAssembly = Assembly.GetExecutingAssembly();
        var currentContext = AssemblyLoadContext.GetLoadContext(currentAssembly);
        if (currentContext != null)
            currentContext.Unloading += OnPluginUnloadingRequested;
    }

    /// <summary>
    /// Uploads a single file to Azure blob storage.
    /// [Documentation](https://tasks.frends.com/tasks/frends-tasks/Frends.AzureBlobStorage.UploadBlob)
    /// </summary>
    /// <param name="source">Source parameters</param>
    /// <param name="destination">Destination parameters</param>
    /// <param name="cancellationToken">Token generated by Frends to stop this Task.</param>
    /// <returns>Object { string Uri, string SourceFile }</returns>
    public static async Task<Result> UploadBlob([PropertyTab] Source source, [PropertyTab] Destination destination, CancellationToken cancellationToken)
    {
        var fi = new FileInfo(source.SourceFile);
        CheckParameters(destination, fi);
        
        var blob = GetBlobClient(destination);

        if (destination.HandleExistingFile is HandleExistingFile.Error && await BlobExists(blob, destination, cancellationToken)) throw new Exception("UploadBlob: Blob already exists.");
        if (destination.HandleExistingFile is HandleExistingFile.Overwrite && await BlobExists(blob, destination, cancellationToken)) await blob.DeleteIfExistsAsync(DeleteSnapshotsOption.None, null, cancellationToken);
        if (destination.HandleExistingFile is HandleExistingFile.Append && await BlobExists(blob, destination, cancellationToken)) fi = await AppendAny(blob, source, destination, cancellationToken);

        if (fi != null)
        {
            var fileName = RenameFile(source, destination, fi);
            return await HandleUpload(source, destination, fi, fileName, cancellationToken);
        }
        else
            return new Result(source.SourceFile, blob.Uri.ToString());
    }

    private static BlobClient GetBlobClient(Destination destination)
    {
        if (destination.ConnectionMethod is ConnectionMethod.ConnectionString)
            return new BlobClient(destination.ConnectionString, destination.ContainerName, destination.BlobName);
        else
        {
            var credentials = new ClientSecretCredential(destination.TenantID, destination.ApplicationID, destination.ClientSecret, new ClientSecretCredentialOptions());
            var url = new Uri($"https://{destination.StorageAccountName}.blob.core.windows.net/{destination.ContainerName}/{destination.BlobName}");
            return new BlobClient(url, credentials);
        }
    }

    private static async Task<Result> HandleUpload(Source source, Destination destination, FileInfo fi, string fileName, CancellationToken cancellationToken)
    {
        if (destination.CreateContainerIfItDoesNotExist && destination.ConnectionMethod is ConnectionMethod.ConnectionString)
            await CreateContainerIfItDoesNotExist(destination, cancellationToken);

        var contentType = string.IsNullOrWhiteSpace(destination.ContentType) ? MimeUtility.GetMimeMapping(fi.Name) : destination.ContentType;
        var encoding = GetEncoding(destination.FileEncoding);

        var progressHandler = new Progress<long>(progress => { Console.WriteLine("Bytes uploaded: {0}", progress); });
        
        switch (destination.BlobType)
        {
            case AzureBlobType.Append:
                try
                {
                    AppendBlobClient appendBlobClient;
                    if (destination.ConnectionMethod is ConnectionMethod.ConnectionString)
                        appendBlobClient = new AppendBlobClient(destination.ConnectionString, destination.ContainerName, fileName);
                    else
                    {
                        var credentials = new ClientSecretCredential(destination.TenantID, destination.ApplicationID, destination.ClientSecret, new ClientSecretCredentialOptions());
                        var url = new Uri($"https://{destination.StorageAccountName}.blob.core.windows.net/{destination.ContainerName}/{fileName}");
                        appendBlobClient = new AppendBlobClient(url, credentials);
                    }

                    var appendBlobCreateOptions = new AppendBlobCreateOptions { HttpHeaders = new BlobHttpHeaders { ContentType = contentType, ContentEncoding = source.Compress ? "gzip" : encoding.WebName } };
                    await appendBlobClient.CreateAsync(appendBlobCreateOptions, cancellationToken);
                    using var appendGetStream = GetStream(false, true, encoding, fi);
                    await appendBlobClient.AppendBlockAsync(appendGetStream, null, null, progressHandler, cancellationToken);
                    return new Result(source.SourceFile, appendBlobClient.Uri.ToString());
                }
                catch (Exception ex)
                {
                    throw new Exception($"UploadBlob (Append): An error occured while uploading file. {ex}");
                }

            case AzureBlobType.Block:
                try
                {
                    BlobClient blobClient;
                    if (destination.ConnectionMethod is ConnectionMethod.ConnectionString)
                        blobClient = new BlobClient(destination.ConnectionString, destination.ContainerName, fileName);
                    else
                    {
                        var credentials = new ClientSecretCredential(destination.TenantID, destination.ApplicationID, destination.ClientSecret, new ClientSecretCredentialOptions());
                        var url = new Uri($"https://{destination.StorageAccountName}.blob.core.windows.net/{destination.ContainerName}/{fileName}");
                        blobClient = new BlobClient(url, credentials);
                    }

                    var blobUploadOptions = new BlobUploadOptions
                    {
                        ProgressHandler = progressHandler,
                        TransferOptions = new StorageTransferOptions { MaximumConcurrency = destination.ParallelOperations },
                        HttpHeaders = new BlobHttpHeaders { ContentType = contentType, ContentEncoding = source.Compress ? "gzip" : encoding.WebName }
                    };
                    using var blockGetStream = GetStream(source.Compress, source.ContentsOnly, encoding, fi);
                    await blobClient.UploadAsync(blockGetStream, blobUploadOptions, cancellationToken);

                    //Delete temp file
                    if (Path.GetDirectoryName(fi.FullName) != Path.GetDirectoryName(source.SourceFile)) fi.Delete();
                    return new Result(source.SourceFile, blobClient.Uri.ToString());

                }
                catch (Exception ex)
                {
                    throw new Exception($"UploadBlob (Block): An error occured while uploading file. {ex}");
                }

            case AzureBlobType.Page:
                try
                {
                    PageBlobClient pageBlobClient;
                    if (destination.ConnectionMethod is ConnectionMethod.ConnectionString)
                        pageBlobClient = new PageBlobClient(destination.ConnectionString, destination.ContainerName, fileName);
                    else
                    {
                        var credentials = new ClientSecretCredential(destination.TenantID, destination.ApplicationID, destination.ClientSecret, new ClientSecretCredentialOptions());
                        var url = new Uri($"https://{destination.StorageAccountName}.blob.core.windows.net/{destination.ContainerName}/{fileName}");
                        pageBlobClient = new PageBlobClient(url, credentials);
                    }

                    var maxSize = destination.PageMaxSize < 512 ? 512 : destination.PageMaxSize;
                    var fiMinLenght = fi.Length;

                    //Upload size can't be over Page's full size.
                    while (maxSize % 512 != 0) maxSize += (maxSize / 512);
                    while (fiMinLenght % 512 != 0) fiMinLenght += (fiMinLenght / 512);
                    while (maxSize < fiMinLenght) maxSize += 512;

                    if (destination.HandleExistingFile.Equals(HandleExistingFile.Overwrite)) await pageBlobClient.DeleteIfExistsAsync(DeleteSnapshotsOption.None, null, cancellationToken);

                    if (fiMinLenght > 8796093022208 || maxSize > 8796093022208) //Handle over 8 TB
                        throw new Exception($"UploadPageBlob: Required minimum size of Page is over 8 TB. File's minumum size: {fiMinLenght} bytes, Page maximum size: {maxSize} bytes.");

                    using var pageGetStream = GetStream(false, true, encoding, fi);
                    await pageBlobClient.CreateAsync(maxSize, cancellationToken: cancellationToken);
                    await pageBlobClient.UploadPagesAsync(pageGetStream, destination.PageOffset == -1 ? maxSize - fiMinLenght : destination.PageOffset, cancellationToken: cancellationToken);

                    //Delete temp file
                    if (Path.GetDirectoryName(fi.FullName) != Path.GetDirectoryName(source.SourceFile)) fi.Delete();

                    return new Result(source.SourceFile, pageBlobClient.Uri.ToString());
                }
                catch (Exception ex)
                {
                    throw new Exception($"UploadBlob (Page): An error occured while uploading file. {ex}");
                }

            ////Handle CS0161
            default: throw new Exception("HandleUpload: An error occured while uploading file. Missing Azure Blob type."); // return new Result { SourceFile = source.SourceFile, Uri = null };
        }

    }

    private static async Task<bool> BlobExists(BlobClient blob, Destination destination, CancellationToken cancellationToken)
    {
        try
        {
            return await blob.ExistsAsync(cancellationToken);
        }
        catch (Exception ex)
        {
            throw new Exception($"BlobExists: An error occured while checking if blob exists. {ex}");
        }
    }

    private static string RenameFile(Source source, Destination destination, FileInfo fi)
    {
        try
        {
            string fileName;
            if (string.IsNullOrWhiteSpace(destination.RenameTo) && source.Compress) fileName = fi.Name + ".gz";
            else if (string.IsNullOrWhiteSpace(destination.RenameTo)) fileName = fi.Name;
            else fileName = destination.RenameTo;
            return fileName;
        }
        catch (Exception ex)
        {
            throw new Exception($"RenameFile: An error occured while renaming file. {ex}");
        }
    }

    private static async Task CreateContainerIfItDoesNotExist(Destination destination, CancellationToken cancellationToken)
    {
        try
        {
            BlobServiceClient blobServiceClient;

            if (destination.ConnectionMethod is ConnectionMethod.ConnectionString)
                blobServiceClient = new BlobServiceClient(destination.ConnectionString);
            else
                throw new Exception($"CreateContainerIfItDoesNotExist: CreateContainerIfItDoesNotExist is not supported with OAuth2");

            var container = blobServiceClient.GetBlobContainerClient(destination.ContainerName);
            await container.CreateIfNotExistsAsync(PublicAccessType.None, null, null, cancellationToken);
        }
        catch (Exception ex)
        {
            throw new Exception($"CreateContainerIfItDoesNotExist: An error occured while checking if container exists or while creating a new container.{ex}");
        }
    }

    private static async Task<FileInfo> AppendAny(BlobClient blob, Source source, Destination destination, CancellationToken cancellationToken)
    {
        try
        {
            var blobProperties = blob.GetPropertiesAsync(cancellationToken: cancellationToken);

            //Block and Page blobs must be downloaded and handled in temp because file size can be too large for memory stream.
            if (blobProperties.Result.Value.BlobType.Equals(BlobType.Append))
            {
                AppendBlobClient appendBlobClient;
                if (destination.ConnectionMethod is ConnectionMethod.ConnectionString)
                    appendBlobClient = new AppendBlobClient(destination.ConnectionString, destination.ContainerName, destination.BlobName);
                else
                {
                    var credentials = new ClientSecretCredential(destination.TenantID, destination.ApplicationID, destination.ClientSecret, new ClientSecretCredentialOptions());
                    var url = new Uri($"https://{destination.StorageAccountName}.blob.core.windows.net/{destination.ContainerName}/{destination.BlobName}");
                    appendBlobClient = new AppendBlobClient(url, credentials);
                }

                var appendBlobMaxAppendBlockBytes = appendBlobClient.AppendBlobMaxAppendBlockBytes;

                using var file = File.OpenRead(source.SourceFile);
                int bytesRead;
                var buffer = new byte[appendBlobMaxAppendBlockBytes];
                while ((bytesRead = file.Read(buffer, 0, buffer.Length)) > 0)
                {
                    var newArray = new Span<byte>(buffer, 0, bytesRead).ToArray();
                    Stream stream = new MemoryStream(newArray) { Position = 0 };
                    await appendBlobClient.AppendBlockAsync(stream, cancellationToken: cancellationToken);
                }

                // Return null to skip uploading.
                return null;
            }
            else
            {
                var tempFile = Path.Combine(Path.GetTempPath(), destination.BlobName);
                await blob.DownloadToAsync(tempFile, cancellationToken);

                using (var sourceData = new StreamReader(source.SourceFile))
                using (var destinationFile = File.AppendText(tempFile))
                {
                    var line = sourceData.ReadLine();
                    destinationFile.Write(line); //WriteLine will mess up Page blob upload.
                };

                return new FileInfo(tempFile);
            }
        }
        catch (Exception ex)
        {
            throw new Exception($"AppendAny: An error occured while appending file. {ex}");
        }
    }

    /// <summary>
    /// Gets correct stream object. Does not always dispose, so use using.
    /// </summary>
    private static Stream GetStream(bool compress, bool fromString, Encoding encoding, FileInfo file)
    {
        var fileStream = File.OpenRead(file.FullName);

        if (!compress && !fromString) return fileStream;

        byte[] bytes;
        if (!compress)
        {
            using (var reader = new StreamReader(fileStream, encoding)) bytes = encoding.GetBytes(reader.ReadToEnd());
            return new MemoryStream(bytes);
        }

        using (var outStream = new MemoryStream())
        {
            using (var gzip = new GZipStream(outStream, CompressionMode.Compress))
            {
                if (!fromString) fileStream.CopyTo(gzip);
                else
                    using (var reader = new StreamReader(fileStream, encoding))
                    {
                        var content = reader.ReadToEnd();
                        using var encodedMemory = new MemoryStream(encoding.GetBytes(content));
                        encodedMemory.CopyTo(gzip);
                    }
            }
            bytes = outStream.ToArray();
        }
        fileStream.Dispose();

        var memStream = new MemoryStream(bytes);
        return memStream;
    }

    private static Encoding GetEncoding(string target)
    {
        return target.ToLower() switch
        {
            "utf-32" => Encoding.UTF32,
            "unicode" => Encoding.Unicode,
            "ascii" => Encoding.ASCII,
            _ => Encoding.UTF8,
        };
    }

    private static void CheckParameters(Destination destination, FileInfo fi)
    {
        if (destination.ConnectionMethod is ConnectionMethod.OAuth2 && (destination.ApplicationID is null || destination.ClientSecret is null || destination.TenantID is null || destination.StorageAccountName is null))
            throw new Exception("Destination.StorageAccountName, Destination.ClientSecret, Destination.ApplicationID and Destination.TenantID parameters can't be empty when Destination.ConnectionMethod = OAuth.");
        if (string.IsNullOrWhiteSpace(destination.ConnectionString) && destination.ConnectionMethod is ConnectionMethod.ConnectionString)
            throw new Exception("Destination.ConnectionString parameter can't be empty when Destination.ConnectionMethod = ConnectionString.");
        if (string.IsNullOrWhiteSpace(destination.ContainerName))
            throw new Exception("Destination.ContainerName parameter can't be empty.");

        if (!fi.Exists)
            throw new Exception("Source file doesn't exists.");
    }

    private static void OnPluginUnloadingRequested(AssemblyLoadContext obj)
    {
        obj.Unloading -= OnPluginUnloadingRequested;
    }
}