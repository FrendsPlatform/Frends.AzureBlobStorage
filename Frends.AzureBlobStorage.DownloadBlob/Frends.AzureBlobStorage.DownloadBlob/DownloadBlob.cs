using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.ComponentModel;
using Azure.Storage.Blobs;
using Frends.AzureBlobStorage.DownloadBlob.Definitions;
using Azure.Identity;
using Azure;

namespace Frends.AzureBlobStorage.DownloadBlob;

/// <summary>
/// Azure Blob Storage task.
/// </summary>
public static class AzureBlobStorage
{
    /// <summary>
    /// Downloads Blob from Azure Blob Storage.
    /// [Documentation](https://tasks.frends.com/tasks/frends-tasks/Frends.AzureBlobStorage.DownloadBlob)
    /// </summary>
    /// <param name="source">Information about which Blob to download.</param>
    /// <param name="destination">Information about the download destination.</param>
    /// <param name="cancellationToken">Token generated by Frends to stop this task.</param>
    /// <returns>Object { string FileName, string Directory, string FullPath}</returns>
    public static async Task<Result> DownloadBlob([PropertyTab] Source source, [PropertyTab] Destination destination, CancellationToken cancellationToken)
    {
        try
        {
            var blob = GetBlobClient(source);
            var fullDestinationPath = Path.Combine(destination.Directory, source.BlobName);
            var fileName = source.BlobName.Split('.')[0];
            var fileExtension = "";

            if (source.BlobName.Split('.').Length > 1)
            {
                fileName = string.Join(".", source.BlobName.Split('.').Take(source.BlobName.Split('.').Length - 1).ToArray());
                fileExtension = "." + source.BlobName.Split('.').Last();
            }

            if (destination.FileExistsOperation == FileExistsAction.Error && File.Exists(fullDestinationPath))
                throw new IOException("File already exists in destination path. Please delete the existing file or change the \"file exists operation\" to OverWrite.");

            if (destination.FileExistsOperation == FileExistsAction.Rename && File.Exists(fullDestinationPath))
            {
                var increment = 1;
                var incrementedFileName = $"{fileName}({increment}){fileExtension}";

                while (File.Exists(Path.Combine(destination.Directory, incrementedFileName)))
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    increment++;
                    incrementedFileName = $"{fileName}({increment}){fileExtension}";
                }

                fullDestinationPath = Path.Combine(destination.Directory, incrementedFileName);
                fileName = incrementedFileName;
                await blob.DownloadToAsync(fullDestinationPath, cancellationToken);
            }
            else
            {
                await blob.DownloadToAsync(fullDestinationPath, cancellationToken);
            }

            var encoding = GetEncoding(source.Encoding, source.FileEncodingString, source.EnableBOM);
            CheckAndFixFileEncoding(fullDestinationPath, destination.Directory, fileExtension, encoding);

            return new Result(fileName, destination.Directory, fullDestinationPath);
        }
        catch (Exception ex)
        {
            throw new Exception($"DownloadBlob error: {ex}");
        }
    }

    private static void CheckAndFixFileEncoding(string fullPath, string directory, string fileExtension, Encoding targetEncoding)
    {
        string encoding;

        using (var reader = new StreamReader(fullPath, true))
        {
            reader.Read();
            encoding = reader.CurrentEncoding.BodyName;
        }
        if (targetEncoding.BodyName != encoding)
        {
            var tempFilePath = Path.Combine(directory, "encodingTemp" + fileExtension);
            using (var sr = new StreamReader(fullPath, true))
            using (var sw = new StreamWriter(tempFilePath, false, targetEncoding))
            {
                var line = string.Empty;
                while ((line = sr.ReadLine()) != null)
                    sw.WriteLine(line);
            }
            File.Delete(fullPath);
            File.Copy(tempFilePath, fullPath);
            File.Delete(tempFilePath);
        }
    }

    private static BlobClient GetBlobClient(Source source)
    {
        switch (source.ConnectionMethod)
        {
            case ConnectionMethod.ConnectionString:
                return new BlobClient(source.ConnectionString, source.ContainerName, source.BlobName);
            case ConnectionMethod.OAuth2:
                return new BlobClient(new Uri($"{source.Uri}/{source.ContainerName.ToLower()}/{source.BlobName}"), new ClientSecretCredential(source.TenantID, source.ApplicationID, source.ClientSecret, new ClientSecretCredentialOptions()));
            case ConnectionMethod.SASToken:
                return new BlobClient(new Uri($"{source.Uri}/{source.ContainerName.ToLower()}/{source.BlobName}"), new AzureSasCredential(source.SASToken));
            default: throw new NotSupportedException();
        }
    }

    private static Encoding GetEncoding(FileEncoding encoding, string encodingString, bool enableBom)
    {
        return encoding switch
        {
            FileEncoding.UTF8 => enableBom ? new UTF8Encoding(true) : new UTF8Encoding(false),
            FileEncoding.ASCII => new ASCIIEncoding(),
            FileEncoding.Default => Encoding.Default,
            FileEncoding.WINDOWS1252 => CodePagesEncodingProvider.Instance.GetEncoding("windows-1252"),
            FileEncoding.Other => CodePagesEncodingProvider.Instance.GetEncoding(encodingString),
            _ => throw new ArgumentOutOfRangeException($"Unknown Encoding type: '{encoding}'."),
        };
    }
}