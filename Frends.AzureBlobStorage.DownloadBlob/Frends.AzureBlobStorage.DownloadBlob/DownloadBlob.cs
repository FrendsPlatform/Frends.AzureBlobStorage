using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.ComponentModel;
using Azure.Storage.Blobs;
using Frends.AzureBlobStorage.DownloadBlob.Definitions;
using Azure.Identity;
using Azure;

namespace Frends.AzureBlobStorage.DownloadBlob;

/// <summary>
/// Azure Blob Storage task.
/// </summary>
public static class AzureBlobStorage
{
    /// <summary>
    /// Downloads Blob from Azure Blob Storage.
    /// [Documentation](https://tasks.frends.com/tasks/frends-tasks/Frends.AzureBlobStorage.DownloadBlob)
    /// </summary>
    /// <param name="source">Information about which Blob to download.</param>
    /// <param name="destination">Information about the download destination.</param>
    /// <param name="cancellationToken">Token generated by Frends to stop this task.</param>
    /// <returns>Object { string FileName, string Directory, string FullPath}</returns>
    public static async Task<Result> DownloadBlob([PropertyTab] Source source, [PropertyTab] Destination destination, CancellationToken cancellationToken)
    {
        try
        {
            var blob = GetBlobClient(source);
            var blobFileName = string.IsNullOrWhiteSpace(destination.TargetFileName)
                ? source.BlobName
                : destination.TargetFileName;
            var fullDestinationPath = Path.Combine(destination.Directory, blobFileName);
            var fileName = blobFileName.Split('.')[0];
            var fileExtension = "";

            if (blobFileName.Split('.').Length > 1)
            {
                fileName = string.Join(".", blobFileName.Split('.').Take(blobFileName.Split('.').Length - 1).ToArray());
                fileExtension = "." + blobFileName.Split('.').Last();
            }

            if (destination.FileExistsOperation == FileExistsAction.Error && File.Exists(fullDestinationPath))
                throw new IOException("File already exists in destination path. Please delete the existing file or change the \"file exists operation\" to OverWrite.");

            if (destination.FileExistsOperation == FileExistsAction.Rename && File.Exists(fullDestinationPath))
            {
                var increment = 1;
                var incrementedFileName = $"{fileName}({increment}){fileExtension}";

                while (File.Exists(Path.Combine(destination.Directory, incrementedFileName)))
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    increment++;
                    incrementedFileName = $"{fileName}({increment}){fileExtension}";
                }

                fullDestinationPath = Path.Combine(destination.Directory, incrementedFileName);
                blobFileName = incrementedFileName;
                await blob.DownloadToAsync(fullDestinationPath, cancellationToken);
            }
            else
            {
                await blob.DownloadToAsync(fullDestinationPath, cancellationToken);
            }

            var encoding = GetEncoding(source.Encoding, source.FileEncodingString, source.EnableBOM);
            CheckAndFixFileEncoding(fullDestinationPath, destination.Directory, fileExtension, encoding);

            return new Result(blobFileName, destination.Directory, fullDestinationPath);
        }
        catch (Exception ex)
        {
            throw new Exception($"DownloadBlob error: {ex}");
        }
    }

    private static void CheckAndFixFileEncoding(string fullPath, string directory, string fileExtension, Encoding targetEncoding)
    {
        string encoding;

        using (var reader = new StreamReader(fullPath, true))
        {
            reader.Read();
            encoding = reader.CurrentEncoding.BodyName;
        }

        if (targetEncoding.BodyName != encoding)
        {
            var tempFilePath = Path.Combine(directory, "encodingTemp" + fileExtension);

            using (var sr = new StreamReader(fullPath, true))
            using (var sw = new StreamWriter(tempFilePath, false, targetEncoding))
            {
                var line = string.Empty;
                while ((line = sr.ReadLine()) != null)
                    sw.WriteLine(line);
            }

            File.Delete(fullPath);
            File.Copy(tempFilePath, fullPath);
            File.Delete(tempFilePath);
        }
    }

    private static BlobClient GetBlobClient(Source source)
    {
        switch (source.ConnectionMethod)
        {
            case ConnectionMethod.ConnectionString:
                return new BlobClient(source.ConnectionString, source.ContainerName, source.BlobName);
            case ConnectionMethod.OAuth2:
                return new BlobClient(new Uri($"{source.Uri}/{source.ContainerName.ToLower()}/{source.BlobName}"), new ClientSecretCredential(source.TenantID, source.ApplicationID, source.ClientSecret, new ClientSecretCredentialOptions()));
            case ConnectionMethod.SASToken:
                var containerClient = new BlobContainerClient(new Uri($"{source.Uri}/{source.ContainerName.ToLower()}"), new AzureSasCredential(source.SASToken));

                return containerClient.GetBlobClient(source.BlobName);
            default: throw new NotSupportedException();
        }
    }

    private static Encoding GetEncoding(FileEncoding encoding, string encodingString, bool enableBom)
    {
        switch (encoding)
        {
            case FileEncoding.UTF8:
                return enableBom ? new UTF8Encoding(true) : new UTF8Encoding(false);
            case FileEncoding.ASCII:
                return new ASCIIEncoding();
            case FileEncoding.Default:
                return Encoding.Default;
            case FileEncoding.WINDOWS1252:
                return CodePagesEncodingProvider.Instance.GetEncoding("windows-1252");
            case FileEncoding.Other:
                try
                {
                    var encodingFromString = CodePagesEncodingProvider.Instance.GetEncoding(encodingString);

                    if (encodingFromString == null)
                        throw new ArgumentException($"Encoding '{encodingString}' is not supported.");

                    return encodingFromString;
                }
                catch (ArgumentException ex)
                {
                    throw new ArgumentException($"Invalid encoding string '{encodingString}': {ex.Message}");
                }
            default:
                throw new ArgumentOutOfRangeException($"Unknown Encoding type: '{encoding}'.");
        }
    }
}