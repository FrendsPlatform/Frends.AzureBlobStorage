using Azure;
using Azure.Identity;
using Azure.Storage.Blobs;
using Azure.Storage.Blobs.Models;
using Frends.AzureBlobStorage.WriteBlob.Definitions;
using Frends.AzureBlobStorage.WriteBlob.Enums;
using MimeMapping;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO.Compression;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace Frends.AzureBlobStorage.WriteBlob;

/// <summary>
/// Azure Blob Storage Task.
/// </summary>
public class AzureBlobStorage
{
    /// <summary>
    /// Frends Task to write content to Azure Blob Storage.
    /// [Documentation](https://tasks.frends.com/tasks/frends-tasks/Frends.AzureBlobStorage.WriteBlob)
    /// </summary>
    /// <param name="source">Source parameters.</param>
    /// <param name="destination">Destination parameters.</param>
    /// <param name="options">Optional parameters.</param>
    /// <param name="cancellationToken">Token generated by Frends to stop this Task.</param>
    /// <returns>Object { bool Success, BlobContentInfo Info, string Uri }</returns>
    public static async Task<Result> WriteBlob([PropertyTab] Source source, [PropertyTab] Destination destination, [PropertyTab] Options options, CancellationToken cancellationToken)
    {
        CheckDestinationParameters(destination);

        try
        {
            BlobClient blobClient;
            BlobServiceClient blobServiceClient = null;

            switch (destination.ConnectionMethod)
            {
                case ConnectionMethod.ConnectionString:
                    blobServiceClient = new BlobServiceClient(destination.ConnectionString);
                    blobClient = new BlobClient(destination.ConnectionString, destination.ContainerName.ToLower(), destination.BlobName);
                    break;
                case ConnectionMethod.SASToken:
                    var blobContainerClient = new BlobContainerClient(new Uri($"{destination.Uri}/{destination.ContainerName}?"), new AzureSasCredential(destination.SASToken));
                    blobClient = blobContainerClient.GetBlobClient(destination.BlobName);
                    break;
                case ConnectionMethod.OAuth2:
                    var serviceURI = new Uri($"{destination.Uri}");
                    var credentials = new ClientSecretCredential(destination.TenantID, destination.ApplicationID, destination.ClientSecret, new ClientSecretCredentialOptions());
                    blobServiceClient = new BlobServiceClient(serviceURI, credentials);
                    var uri = new Uri($"{destination.Uri}/{destination.ContainerName.ToLower()}/{destination.BlobName}");
                    blobClient = new BlobClient(uri, credentials);
                    break;
                default: throw new NotSupportedException();
            }

            if (destination.CreateContainerIfItDoesNotExist && (destination.ConnectionMethod is ConnectionMethod.ConnectionString || destination.ConnectionMethod is ConnectionMethod.OAuth2))
                await CreateContainerIfItDoesNotExist(blobServiceClient, destination.ContainerName.ToLower(), cancellationToken);

            var info = await HandleWrite(blobClient, source, destination, cancellationToken);
            return new Result(true, info, blobClient.Uri.ToString());
        }
        catch (Exception)
        {
            if (options.ThrowErrorOnFailure)
                throw;

            return new Result(false, null, null);
        }
    }

    private static async Task<BlobContentInfo> HandleWrite(BlobClient blobClient, Source source, Destination destination, CancellationToken cancellationToken)
    {
        var overwrite = destination.HandleExistingFile == HandleExistingFile.Overwrite;
        var encoding = GetEncoding(source.Encoding, source.FileEncodingString, source.EnableBOM) ?? throw new Exception("Encoding was invalid.");
        byte[] bytes = source.SourceType == SourceType.String ? encoding.GetBytes(source.ContentString) : source.ContentBytes;
        if (destination.Compress)
            bytes = Compress(bytes);
        var tags = destination.Tags != null ? destination.Tags.ToDictionary(tag => tag.Name, tag => tag.Value) : new Dictionary<string, string>();

        var uploadOptions = new BlobUploadOptions
        {
            Conditions = overwrite ? null : new BlobRequestConditions { IfNoneMatch = new ETag("*") },
            HttpHeaders = new BlobHttpHeaders { ContentType = MimeUtility.GetMimeMapping(destination.Compress ? "gz" : destination.BlobName), ContentEncoding = encoding.WebName },
            Tags = tags.Count > 0 ? tags : null
        };

        return await blobClient.UploadAsync(BinaryData.FromBytes(bytes), uploadOptions, cancellationToken).ConfigureAwait(false);
    }

    private static async Task CreateContainerIfItDoesNotExist(BlobServiceClient blobServiceClient, string containerName, CancellationToken cancellationToken)
    {
        try
        {
            var container = blobServiceClient.GetBlobContainerClient(containerName);
            await container.CreateIfNotExistsAsync(PublicAccessType.None, null, null, cancellationToken);
        }
        catch (Exception ex)
        {
            throw new Exception($"An error occurred while checking if container exists or while creating a new container.", ex);
        }
    }

    private static Encoding GetEncoding(FileEncoding encoding, string encodingString, bool enableBom)
    {
        return encoding switch
        {
            FileEncoding.UTF8 => enableBom ? new UTF8Encoding(true) : new UTF8Encoding(false),
            FileEncoding.ASCII => new ASCIIEncoding(),
            FileEncoding.Default => Encoding.Default,
            FileEncoding.WINDOWS1252 => CodePagesEncodingProvider.Instance.GetEncoding("windows-1252"),
            FileEncoding.Other => CodePagesEncodingProvider.Instance.GetEncoding(encodingString),
            _ => throw new ArgumentOutOfRangeException($"Unknown Encoding type: '{encoding}'."),
        };
    }

    private static void CheckDestinationParameters(Destination destination)
    {
        if (destination.ConnectionMethod is ConnectionMethod.OAuth2 && (string.IsNullOrEmpty(destination.ApplicationID) || string.IsNullOrEmpty(destination.ClientSecret) || string.IsNullOrEmpty(destination.TenantID) || string.IsNullOrEmpty(destination.Uri)))
            throw new Exception("Destination.Uri, Destination.ClientSecret, Destination.ApplicationID, and Destination.TenantID parameters can't be empty when Destination.ConnectionMethod = OAuth2.");
        if (destination.ConnectionMethod is ConnectionMethod.ConnectionString && string.IsNullOrEmpty(destination.ConnectionString))
            throw new Exception("Destination.ConnectionString parameter can't be empty when Destination.ConnectionMethod = ConnectionString.");
        if (destination.ConnectionMethod is ConnectionMethod.SASToken && (string.IsNullOrEmpty(destination.SASToken) || string.IsNullOrEmpty(destination.Uri)))
            throw new Exception("Destination.SASToken and Destination.URI parameters can't be empty when Destination.ConnectionMethod = SASToken.");
        if (string.IsNullOrEmpty(destination.ContainerName))
            throw new Exception("Destination.ContainerName parameter can't be empty.");
        if (string.IsNullOrEmpty(destination.BlobName))
            throw new Exception("Blob name parameter can't be empty.");
        ValidateContainerName(destination.ContainerName);
    }

    private static void ValidateContainerName(string container)
    {
        if (container.Length < 3)
            throw new Exception("Container name is too short. Name needs to be between 3 and 63 characters.");
        if (container.Length > 63)
            throw new Exception("Container name is too long. Name needs to be between 3 and 63 characters.");
        if (!Regex.IsMatch(container, @"^[a-z0-9]+(-[a-z0-9]+)*$"))
            throw new Exception("Container name includes invalid characters. See more information: https://learn.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata#container-names");
    }

    private static byte[] Compress(byte[] original)
    {
        using var msi = new MemoryStream(original);
        using var mso = new MemoryStream();
        using (var gs = new GZipStream(mso, CompressionMode.Compress))
        {
            CopyTo(msi, gs);
        }

        return mso.ToArray();
    }

    private static void CopyTo(Stream src, Stream dest)
    {
        byte[] bytes = new byte[4096];

        int cnt;

        while ((cnt = src.Read(bytes, 0, bytes.Length)) != 0)
        {
            dest.Write(bytes, 0, cnt);
        }
    }
}